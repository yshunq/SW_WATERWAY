C51 COMPILER V9.00   ADC                                                                   10/11/2024 17:50:12 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN ..\hex\adc.obj
COMPILER INVOKED BY: C:\Keil _C51\C51\BIN\C51.EXE ..\user\adc.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(..\user;..\display
                    -;..\common;..\cut;..\count) DEBUG OBJECTEXTEND PRINT(.\LIST\adc.lst) OBJECT(..\hex\adc.obj)

line level    source

   1          #include "adc.h"
   2          
   3          code float TEMP_DATA[]={
   4                  132284,98185,73626,55744,42592,32814,25497,19958,15742,12504, //-25 -20 -15 -10 -5 0 5 10 15 20
   5                   10000, 8049, 6520, 5313, 4354, 3588, 2973, 2476, 2072, 1742, //25 30 35 40 45 50 55 60 65 70
   6                    1472, 1249, 1065,  911,  783,  675,  585,  508,  443,  388, //75 80 85 90 95 100 105 110 115 120
   7          };
   8          
   9          void ADC_Init(void)//P1.0  P1.1
  10          {
  11   1        //P1M0 = 0x00;                              //设置P1.0为ADC口 高阻输入
  12   1        //P1M1 = 0x01;
  13   1        ADCCFG = 0x2f;                              //设置ADC时钟为系统时钟/2/16/16 转换结果右对齐
  14   1        ADC_CONTR = 0x80;                           //使能ADC模块 打开ADC_POWER
  15   1      }
  16          
  17          float get_adc_temp(u8 adc)
  18          {
  19   1              u16 i;
  20   1              float temp,buff,adc_val,lg1,rval;
  21   1              ADC_CONTR &=~0x80;
  22   1              _nop_();_nop_();
  23   1              ADC_CONTR = 0x80;                       //使能ADC模块 打开ADC_POWER
  24   1              _nop_();_nop_();
  25   1              ADC_CONTR |= (0x40 + adc);              //启动AD转换  ADC_START = 1      ADC2
  26   1              _nop_();_nop_();
  27   1              while (!(ADC_CONTR & 0x20));            //查询ADC完成标志
  28   1              ADC_CONTR &= ~0x20;                     //清完成标志
  29   1      
  30   1              buff = (ADC_RES<<8)|ADC_RESL;                                           //取转换结果
  31   1              //adc_val = 5000*buff/1024;                                                     //计算出电压值
  32   1              //adc_val = 625*buff/128;                                                       //计算出电压值
  33   1              adc_val = 5*buff/1023;
  34   1      //      DIS_FONT_WEI_NUMBER_CM(1,1,0xf8,0x00,0x01,adc_val*1000,5,500,150);
  35   1      
  36   1              if(adc_val>4.7){//拔掉NTC
  37   2                  temp = 124.9;
  38   2                      goto over_water_temp;
  39   2              }else if(adc_val < 0.3){//NTC短路
  40   2                      temp = 124.8;
  41   2                      goto over_water_temp;
  42   2              }
  43   1              
  44   1              lg1 = (5 - adc_val)/10000;                                      //电流流过10K电流
  45   1              rval = adc_val/lg1;                                             //电压除以电流等于电阻
  46   1      
  47   1      //      DIS_FONT_WEI_NUMBER_CM(1,1,0xf8,0x00,0x01,lg1*1000,5,500,50);
  48   1      //      DIS_FONT_WEI_NUMBER_CM(1,1,0xf8,0x00,0x01,rval,5,500,100);
  49   1      
  50   1              if(rval >= 132284){ //小于-25度时显示-25℃
  51   2                      temp = 0;
  52   2                      goto over_water_temp;
  53   2              }
  54   1              
C51 COMPILER V9.00   ADC                                                                   10/11/2024 17:50:12 PAGE 2   

  55   1              if(rval <= 911){        //大于90度时显示90℃
  56   2                      temp = 115;
  57   2                      goto over_water_temp;
  58   2              }
  59   1              
  60   1              for(i=0;i<24;i++){ //对比组织表
  61   2                      buff=(float)TEMP_DATA[i];
  62   2                      if(rval>=buff)
  63   2                      break;
  64   2              }
  65   1              //(TEMP_DATA[i+1] - TEMP_DATA[i])/((5*(i+1)-(5*i)) = (rval - TEMP_DATA[i])/ ?  
  66   1              temp = (rval - TEMP_DATA[i])*5/(TEMP_DATA[i+1] - TEMP_DATA[i]) + 5*i;
  67   1              over_water_temp:
  68   1              _nop_();
  69   1              return temp;
  70   1      }
  71          
  72          float get_adc_val(u8 adc)//获取电压值
  73          {
  74   1              float buff,adc_val;
  75   1              ADC_CONTR &=~0x80;
  76   1              _nop_();_nop_();
  77   1              ADC_CONTR = 0x80;                       //使能ADC模块 打开ADC_POWER
  78   1              _nop_();_nop_();
  79   1              ADC_CONTR |= (0x40 + adc);              //启动AD转换  ADC_START = 1      ADC2
  80   1              _nop_();_nop_();
  81   1              while (!(ADC_CONTR & 0x20));            //查询ADC完成标志
  82   1              ADC_CONTR &= ~0x20;                     //清完成标志
  83   1      
  84   1              buff = (ADC_RES<<8)|ADC_RESL;                                           //取转换结果
  85   1              //adc_val = 5000*buff/1024;                                                     //计算出电压值
  86   1              //adc_val = 625*buff/128;                                                       //计算出电压值
  87   1              adc_val = 5*buff/1023;
  88   1      
  89   1              return adc_val;
  90   1      }
  91          
  92          
  93          
  94          
  95          
  96          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    597    ----
   CONSTANT SIZE    =    120    ----
   XDATA SIZE       =   ----      22
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
